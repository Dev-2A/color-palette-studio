/**
 * Palette Generator
 * íŒ”ë ˆíŠ¸ ìƒì„± ë° í‘œì‹œ
 * - Generate new color palettes
 * - Display palettes on screen
 * - Handle color card interactions
 * - Toggle color locks
 */

// ìƒˆ íŒ”ë ˆíŠ¸ ìƒì„±
function generatePalette() {
  const newPalette = [];

  if (currentTheme && currentMode === 'random') {
    currentPalette = generateThemePalette(currentTheme);
    displayPalette();
    addToHistory(currentPalette);

    // ì‹¤ì‹œê°„ ë¹„êµ ëª¨ë“œì¼ ë•Œ ì—…ë°ì´íŠ¸
    if (typeof compareMode !== 'undefined' && compareMode.liveCompareActive) {
      setTimeout(() => updateLiveComparison(), 100);
    }
    return;
  }

  if (currentMode === 'random') {
    // ëœë¤ ëª¨ë“œ
    for (let i = 0; i < 5; i++) {
      if (lockedColors.has(i) && currentPalette[i]) {
        newPalette.push(currentPalette[i]);
      } else {
        newPalette.push(randomColor());
      }
    }
  } else {
    // ì¡°í™” ëª¨ë“œ
    const baseColor = lockedColors.size > 0 && currentPalette[Array.from(lockedColors)[0]]
      ? currentPalette[Array.from(lockedColors)[0]]
      : randomColor();

    let generatedColors;
    switch(currentMode) {
      case 'complementary':
        generatedColors = generateComplementary(baseColor);
        break;
      case 'analogous':
        generatedColors = generateAnalogous(baseColor);
        break;
      case 'triadic':
        generatedColors = generateTriadic(baseColor);
        break;
      case 'monochromatic':
        generatedColors = generateMonochromatic(baseColor);
        break;
      default:
        generatedColors = Array(5).fill().map(() => randomColor());
    }

    // ì ê¸´ ìƒ‰ìƒ ìœ ì§€
    for (let i = 0; i < 5; i++) {
      if (lockedColors.has(i) && currentPalette[i]) {
        newPalette.push(currentPalette[i]);
      } else {
        newPalette.push(generatedColors[i]);
      }
    }
  }

  currentPalette = newPalette;
  displayPalette();
  addToHistory(currentPalette);

  // ì‹¤ì‹œê°„ ë¹„êµ ëª¨ë“œì¼ ë•Œ ì—…ë°ì´íŠ¸
  if (typeof compareMode !== 'undefined' && compareMode.liveCompareActive) {
    setTimeout(() => updateLiveComparison(), 100);
  }
}

// íŒ”ë ˆíŠ¸ í™”ë©´ì— í‘œì‹œ
function displayPalette() {
  elements.palette.innerHTML = '';

  currentPalette.forEach((color, index) => {
    const rgb = hexToRgb(color);
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

    const temperature = analyzeColorTemperature(color);

    // ìƒ‰ìƒ ì¹´ë“œ ìƒì„±
    const card = document.createElement('div');
    card.className = 'color-card';
    card.dataset.index = index;
    card.innerHTML = `
      <div class="color-preview" style="background: ${color};">
        <button class="lock-btn ${lockedColors.has(index) ? 'locked' : ''}" data-index="${index}">
          ${lockedColors.has(index) ? 'ğŸ”’' : 'ğŸ”“'}
        </button>

        <div class="color-temperature" title="${temperature.label}">
          <span class="temp-icon">${temperature.icon}</span>
        </div>
      </div>
      <div class="color-info">
        <div class="color-temp-info">
          <span class="temp-badge" style="background: ${temperature.color}20; color: ${temperature.color};">
            ${temperature.icon} ${temperature.label}
          </span>
        </div>

        ${showColorNames ? `<div class="color-name">${getColorName(color)}</div>` : ''}

        <div class="color-code" data-value="${color}">
          <span class="color-label">HEX</span>
          <span class="color-value">${color.toUpperCase()}</span>
        </div>
        <div class="color-code" data-value="rgb(${rgb.r}, ${rgb.g}, ${rgb.b})">
          <span class="color-label">RGB</span>
          <span class="color-value">${rgb.r}, ${rgb.g}, ${rgb.b}</span>
        </div>
        <div class="color-code" data-value="hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)">
          <span class="color-label">HSL</span>
          <span class="color-value">${hsl.h}Â°, ${hsl.s}%, ${hsl.l}%</span>
        </div>
      </div>
    `;

    elements.palette.appendChild(card);
  });

  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
  addColorCardListeners();

  updateScoreBadge();
}

// ìƒ‰ìƒ ì¹´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
function addColorCardListeners() {
  // ì ê¸ˆ ë²„íŠ¼
  document.querySelectorAll('.lock-btn').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      const index = parseInt(this.dataset.index);
      toggleLock(index);
    });
  });

  // ìƒ‰ìƒ ì½”ë“œ ë³µì‚¬
  document.querySelectorAll('.color-code').forEach(code => {
    code.addEventListener('click', function() {
      copyToClipboard(this.dataset.value);
    });
  });

  // ìƒ‰ìƒ í”„ë¦¬ë·° í´ë¦­ ì‹œ HEX ë³µì‚¬
  document.querySelectorAll('.color-preview').forEach((preview, index) => {
    preview.addEventListener('click', function(e) {
      if (!e.target.classList.contains('lock-btn')) {
        copyToClipboard(currentPalette[index]);
      }
    });
  });
}

// ìƒ‰ìƒ ì ê¸ˆ í† ê¸€
function toggleLock(index) {
  if (lockedColors.has(index)) {
    lockedColors.delete(index);
  } else {
    lockedColors.add(index);
  }
  displayPalette();
}
